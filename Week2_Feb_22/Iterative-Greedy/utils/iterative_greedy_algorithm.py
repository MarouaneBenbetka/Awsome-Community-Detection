import numpy as np
from utils.communities_network import modularity_matrix, modularity, filter_adj_matrix
from utils.visualization_animation import communities_to_frame
from tqdm.notebook import tqdm


def GCP(adj_matrix: np.ndarray) -> list:
    """
    Greedy Constructive Procedure (GCP) for generating an initial solution for the iterative greedy metaheuristic.

    The method for generating the initial solution, called Greedy Constructive Procedure (GCP),
    follows a traditional greedy approach, where each node is added to the best cluster according to
    a greedy function value. Additionally, the method is randomized in order to increase the diversity of the solutions generated.

    Args:
        adj_matrix (np.ndarray): Adjacency matrix representing the graph.

    Returns:
        tuple: A tuple containing the communities (clusters) generated by GCP and the modularity value of the solution.
    """

    V = list(range(adj_matrix.shape[0]))

    v = np.random.choice(V)
    V.remove(v)

    K0 = [v]
    communities = [K0]
    nodes = [v]

    Mdb = -1

    while V:
        v = np.random.choice(V)
        nodes.append(v)

        Mdb = -1
        best_community = None
        best_community_index = -1

        new_adj_matrix = filter_adj_matrix(
            adj_matrix, nodes)

        for i, Ki in enumerate(communities):
            Ki_new = Ki + [v]

            new_communities = communities.copy()

            new_communities[i] = Ki_new

            Md = modularity(new_adj_matrix, new_communities)

            if Md > Mdb:
                Mdb = Md
                best_community = Ki_new
                best_community_index = i

        if len(nodes) > 1:
            new_adj_matrix = filter_adj_matrix(adj_matrix, nodes)
            Mdphi = modularity(new_adj_matrix, communities + [[v]])
        else:
            Mdphi = -1

        if Mdb > Mdphi:
            communities[best_community_index] = best_community
        else:

            Mdb = Mdphi
            Ki = [v]
            communities.append(Ki)

        V.remove(v)

    return communities, Mdb


def destruct(adj_matrix: np.ndarray, communities: list, beta: float) -> tuple:
    """
    The destruction phase of the IG algorithm starts from a feasible
    solution generated with the constructive method described in Section.
    This phase is devoted to perturb the incumbent solution and requires
    a parameter β that controls the perturbation size. Specifically, the
    destruction phase consists of randomly removing β · n nodes from
    their corresponding clusters, which will be later reassigned in the
    reconstruction phase.

    Parameters:
    adj_matrix (np.ndarray): The adjacency matrix of the graph.
    communities (list): The list of communities in the current solution.
    beta (float): The parameter that controls the perturbation size.

    Returns:
    tuple: A tuple containing the removed nodes and the filtered communities.
    """
    nodes = list(range(adj_matrix.shape[0]))

    removed_nodes = np.random.choice(
        nodes, int(beta * len(nodes)), replace=False)

    filtered_communities = []
    for community in communities:

        new_community = [
            node for node in community if node not in removed_nodes]

        if new_community:
            filtered_communities.append(new_community)

    return removed_nodes, filtered_communities


def reconstruct(adj_matrix: np.ndarray, communities: list, removed_nodes: list) -> tuple:
    """
    Reconstructs the communities after removing nodes from the adjacency matrix.
    Each node is assigned to the community that maximizes the modularity.

    Args:
        adj_matrix (np.ndarray): The adjacency matrix representing the graph.
        communities (list): The list of communities.
        removed_nodes (list): The list of nodes that have been removed.

    Returns:
        tuple: A tuple containing the reconstructed communities and the modularity score.
    """
    nodes = [node for node in list(
        range(adj_matrix.shape[0])) if node not in removed_nodes]

    Mdb = -1

    for node in removed_nodes:
        Mdb = -1
        best_community = None
        best_community_index = -1

        nodes.append(node)

        new_adj_matrix = filter_adj_matrix(adj_matrix, nodes)

        for i, Ki in enumerate(communities):

            Ki_new = Ki + [node]

            new_communities = communities.copy()
            new_communities[i] = Ki_new

            Md = modularity(new_adj_matrix, new_communities)

            if Md > Mdb:
                Mdb = Md
                best_community = Ki_new
                best_community_index = i

        Mdphi = modularity(new_adj_matrix, communities)

        if Mdb >= Mdphi and Mdb != -1:
            communities[best_community_index] = best_community
        else:
            Ki = [node]
            communities.append(Ki)
            Mdb = Mdphi

    return communities, Mdb


def IG(adj_matrix: np.ndarray, nb_iterations=100, beta=.4) -> tuple:
    """
    Iterative Greedy Algorithm (IG) for community detection in a network.

    Parameters:
        adj_matrix (np.ndarray): Adjacency matrix of the network.
        nb_iterations (int): Number of iterations for the algorithm. Default is 100.
        beta (float): Beta parameter for the destruction phase. Default is 0.4.

    Returns:
        tuple: A tuple containing the final communities, modularity trace, communities trace, and frames.

    Description:
        The method starts from an initial solution φ for a given network G .
        The initial solution is generated using the constructive method GCP
        The algorithm stops after performing nb_iterations iterations.
        Each iteration starts with a destruction phase .
        After that, the solution obtained is subjected to a reconstruction process 
        The reconstructed solution φ′ is then accepted if it gives better modularity.
    """
    frames = []
    modularity_trace = []
    communities_trace = []

    communities, mod = GCP(adj_matrix)

    modularity_trace.append(mod)
    frames.append(communities_to_frame(adj_matrix.shape[0], communities, mod))
    communities_trace.append(communities)

    for _ in tqdm(range(nb_iterations), desc="IG", total=nb_iterations):
        removed_nodes, filtered_communities = destruct(
            adj_matrix, communities, beta)

        new_communities, mod = reconstruct(
            adj_matrix, filtered_communities, removed_nodes)

        if modularity(adj_matrix, new_communities) > modularity(adj_matrix, communities):
            communities = new_communities
            modularity_trace.append(mod)
            communities_trace.append(communities)
            frames.append(communities_to_frame(
                adj_matrix.shape[0], communities, mod))

    return communities, modularity_trace, communities_trace, frames
